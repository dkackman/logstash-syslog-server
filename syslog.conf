input {
  tcp {
    id => "syslog-input-tcp"
    port => 1514
    type => syslog
  }
  udp {
    id => "syslog-input-udp"
    port => 514
    type => syslog
  }
}
filter {
  syslog_pri {
    id => "syslog-pri"
  }
  # syslog header parsing
  grok {
    id => "syslog-grok-message"
    match => { 
      "message" => [
        "%{SYSLOGTIMESTAMP:[syslog][timestamp]} %{SYSLOGHOST:[syslog][hostname]} %{DATA:[syslog][program]}(?:\[%{POSINT:[syslog][pid]}\])?: %{GREEDYMULTILINE:[syslog][message]}",
        ">%{DATA:[syslog][program]}(?:\[%{POSINT:[syslog][pid]}\])?: %{GREEDYMULTILINE:[syslog][message]}"
      ] 
    }
    pattern_definitions => { "GREEDYMULTILINE" => "(.|\n)*" }
  }
  # firewall template
  if [syslog][program] == "kernel" and [syslog][message] =~ " IN=" and [syslog][message] =~ " OUT=" {
    grok {
      id => "syslog-grok-firewall-action"
      match => { 
        "[syslog][message]" => [
          "\[UFW %{WORD:[firewall_action]}\] ",
          "%{WORD::[firewall_action]}"
        ] 
      }
    }
    kv {
      id => "syslog-kv-firewall"
      transform_key => "lowercase"
      target => "firewall"
      allow_duplicate_values => false
      whitespace => "strict"
    }
    # get geoip for incoming traffic on red0
    if [firewall][in] == "red0" {
      geoip {
        source => "[firewall][src]"
      }
    }
    # add dns reverse lookup placeholders
    mutate {
        id => "syslog-mutate-firewall"
        add_field => { 
          "[firewall][dst_hostname]" => "%{[firewall][dst]}"
          "[firewall][src_hostname]" => "%{[firewall][src]}"
        }
        rename => { "" => "[firewall][action]" }
    }
    # do reverse dns on known ip fields
    dns {
      id => "syslog-dns-firewall"
      reverse => [ "[firewall][dst_hostname]", "[firewall][src_hostname]" ]
      action => "replace"
      hit_cache_size => 100
      hit_cache_ttl => 86400
    }       
  }
  # snort template  
  else if [syslog][program] == "snort" {
    grok {
      id => "syslog-grok-snort"
      match => { "[syslog][message]" => ["ET %{WORD:[ids][action]} %{GREEDYDATA:[ids][rule]} \[Classification: %{DATA:[ids][classification]}\] \[Priority: %{NUMBER:[ids][priority]}\] {%{WORD:[ids][protocol]}} %{IP:[ids][src]}:%{NUMBER:[ids][src_port]} -> %{IP:[ids][dst]}:%{NUMBER:[ids][dst_port]}"] }
    }
    geoip {
      source => "[ids][src]"
    }    
    # add dns reverse lookup placeholders
    mutate {
        id => "syslog-mutate-snort"
        add_field => { 
          "[ids][dst_hostname]" => "%{[ids][dst]}"
          "[ids][src_hostname]" => "%{[ids][src]}"
        }
    }   
    # do reverse dns on known ip addresses
    dns {
      id => "syslog-dns-snort"
      reverse => [ "[ids][dst_hostname]", "[ids][src_hostname]" ]
      action => "replace"
      hit_cache_size => 100
      hit_cache_ttl => 86400
    }
  }
  # ssh template
  else if [syslog][program] == "sshd" {
    grok {
      id => "syslog-grok-sshd"
      match => { 
        "[syslog][message]" => [
          "Invalid user %{WORD:[ssh][user]} from %{IP:[ssh][src]} port %{NUMBER:[ssh][port]}",
          "Connection closed by %{IP:[ssh][src]} port %{NUMBER:[ssh][port]} \[preauth\]",
          "Server listening on %{IP:[ssh][listening_ip]} port %{NUMBER:[ssh][listening_port]}",
          "line %{NUMBER:[ssh][deprecated_option_line]}: Deprecated option %{WORD:[ssh][deprecated_option]}",
          "Received %{WORD:[syslog][signal]}; restarting",
          "%{WORD:[ssh][result]} %{WORD:[ssh][auth]} for %{WORD:[ssh][user]} from %{IP:[ssh][src]} port %{NUMBER:[ssh][port]} %{WORD:[ssh][version]}: %{WORD:[ssh][cryptosystem]} %{WORD:[ssh][alogrthm]}:%{WORD:[ssh][hash]}"
        ] 
      }
    }    
    if [syslog][message] =~ "Invalid user" or [syslog][message] =~ "Connection closed " {
      mutate {
        id => "syslog-sshd-mutate-rejected-result"
        add_field => { "[ssh][result]" => "Rejected" }
      }
    }
    if "" in [ssh][src] {
      mutate {
        # add dns reverse lookup placeholders      
        id => "syslog-sshd-mutate-src_hostname"
        add_field => { "[ssh][src_hostname]" => "%{[ssh][src]}" }
      }    
      # do reverse dns on known ip addresses
      dns {
        id => "syslog-dns-ssh"
        reverse => [ "[ssh][src_hostname]" ]
        action => "replace"
        hit_cache_size => 100
        hit_cache_ttl => 86400
      }  
    }    
  }
  # sudo template
  else if [syslog][program] == "sudo" {
    grok {
      id => "syslog-grok-sudo"
      match => { 
        "[syslog][message]" => [
          "%{WORD:[sudo_interactive_user]} : %{GREEDYDATA:data}",
          " session %{WORD:[sudo][session]} for user %{WORD:[sudo][user]}"
        ]
      }
    }
    kv {
      id => "syslog-kv-sudo"
      source => "data"
      transform_key => "lowercase"
      field_split => ";"
      trim_key => " "
      trim_value => " "
      target => "sudo"
      allow_duplicate_values => false
      remove_field => "data"
    }   
  }
  # rename some fields to move them to sub objects
  mutate {
    id => "mutate-final"
    rename => { 
      "sudo_interactive_user" => "[sudo][interactive_user]" 
      "firewall_action" => "[firewall][action]" 
      "syslog_severity_code" => "[syslog][severity][code]" 
      "syslog_severity" => "[syslog][severity][name]" 
      "syslog_facility_code" => "[syslog][facility][code]" 
      "syslog_facility" => "[syslog][facility][name]"
    } 
    # remove_field => "message"
  }
}
output {
  elasticsearch {
    id => "syslog-output-es"
    hosts => "localhost:9200"
    manage_template => false
    index => "syslog-%{+YYYY.MM.dd}"
  }
}
