input {
  stdin {
    id => "stdin-test-input"
  }
}
filter {
  syslog_pri {
    id => "syslog-pri"
  }
  # syslog header parsing
  grok {
    id => "syslog-grok-message"
    match => { 
      "message" => [
        "%{SYSLOGTIMESTAMP:[syslog][timestamp]} %{SYSLOGHOST:[syslog][hostname]} %{DATA:[syslog][program]}(?:\[%{POSINT:[syslog][pid]}\])?: %{GREEDYMULTILINE:[syslog][message]}",
        ">%{DATA:[syslog][program]}(?:\[%{POSINT:[syslog][pid]}\])?: %{GREEDYMULTILINE:[syslog][message]}"
      ] 
    }
    pattern_definitions => { "GREEDYMULTILINE" => "(.|\n)*" }
  }
  # syslog timestamps do not include the year (at least in my environment)
  date {
    match => [ "[syslog][timestamp]", "MMM dd yyyy HH:mm:ss", "MMM  d yyyy HH:mm:ss", "MMM dd HH:mm:ss", "MMM  d HH:mm:ss", "ISO8601" ]
    timezone => "America/Chicago"
  }
  # firewall template
  if [syslog][program] == "kernel" and [syslog][message] =~ " IN=" and [syslog][message] =~ " OUT=" {
    grok {
      id => "syslog-grok-firewall-action"
      match => { 
        "[syslog][message]" => [
          "\[UFW %{WORD:[firewall_action]}\] ",
          "%{WORD::[firewall_action]}"
        ]
      }
    }
    kv {
      id => "syslog-kv-firewall"
      transform_key => "lowercase"
      target => "firewall"
      allow_duplicate_values => false
      whitespace => "strict"
    }
    # get geoip for incoming traffic on red0
    if [firewall][in] == "red0" {
      geoip {
        source => "[firewall][src]"
      }
    }
    # add dns reverse lookup placeholders
    mutate {
      id => "syslog-mutate-firewall"
      add_field => { 
        "[firewall][dst_hostname]" => "%{[firewall][dst]}"
        "[firewall][src_hostname]" => "%{[firewall][src]}"
      }
      rename => { "" => "[firewall][action]" }
    }
    # do reverse dns on known ip fields
    dns {
      id => "syslog-dns-firewall"
      reverse => [ "[firewall][dst_hostname]", "[firewall][src_hostname]" ]
      action => "replace"
      hit_cache_size => 100
      hit_cache_ttl => 86400
    }
  }
  # snort template  
  else if [syslog][program] == "snort" {
    grok {
      id => "syslog-grok-snort"
      match => { 
        "[syslog][message]" => [
          "ET %{WORD:[ids][action]} %{GREEDYDATA:[ids][rule]} \[Classification: %{DATA:[ids][classification]}\] \[Priority: %{NUMBER:[ids][priority]}\] {%{WORD:[ids][protocol]}} %{IP:[ids][src]}:%{NUMBER:[ids][src_port]} -> %{IP:[ids][dst]}:%{NUMBER:[ids][dst_port]}",
          "gen-id=%{WORD:[ids][gen_id]}%{SPACE}sig-id=%{WORD:[ids][sig_id]}%{SPACE}type=%{WORD:[ids][type]}%{SPACE}tracking=%{WORD:[ids][tracking]}%{SPACE}count=%{POSINT:[ids][count]}%{SPACE}seconds=%{POSINT:[ids][seconds]}",
          "Preprocessor Object:%{SPACE}%{WORD:[ids][preprocessor_object]}%{SPACE}Version%{SPACE}%{DATA:[ids][preprocessor_version]}%{SPACE}\<Build %{WORD:[ids][preprocessor_build]}\>",
          "%{GREEDYDATA:[ids][message]}"
          ]
        }
    }
    if [ids][src] {
      geoip {
        source => "[ids][src]"
      }
      # add dns reverse lookup placeholders
      mutate {
          id => "syslog-mutate-snort"
          add_field => { 
            "[ids][dst_hostname]" => "%{[ids][dst]}"
            "[ids][src_hostname]" => "%{[ids][src]}"
          }
      }
      # do reverse dns on known ip addresses
      dns {
        id => "syslog-dns-snort"
        reverse => [ "[ids][dst_hostname]", "[ids][src_hostname]" ]
        action => "replace"
        hit_cache_size => 100
        hit_cache_ttl => 86400
      }
    }
  }
  # ssh template
  else if [syslog][program] == "sshd" {
    grok {
      id => "syslog-grok-sshd"
      match => { 
        "[syslog][message]" => [
          "Invalid user %{WORD:[ssh][user]} from %{IP:[ssh][src]} port %{NUMBER:[ssh][port]}",
          "Connection closed by %{IP:[ssh][src]} port %{NUMBER:[ssh][port]} \[preauth\]",
          "Server listening on %{IP:[ssh][listening_ip]} port %{NUMBER:[ssh][listening_port]}",
          "line %{NUMBER:[ssh][deprecated_option_line]}: Deprecated option %{WORD:[ssh][deprecated_option]}",
          "Received %{WORD:[syslog][signal]}; restarting",
          "%{WORD:[ssh][result]} %{WORD:[ssh][auth]} for %{WORD:[ssh][user]} from %{IP:[ssh][src]} port %{NUMBER:[ssh][port]} %{WORD:[ssh][version]}: %{WORD:[ssh][cryptosystem]} %{WORD:[ssh][alogrthm]}:%{WORD:[ssh][hash]}",
          " session %{WORD:[ssh][session]} for user %{WORD:[ssh][user]}",
          "%{GREEDYDATA:[ssh][message]}"                 
        ]
      }
    }    
    if [syslog][message] =~ "Invalid user" or [syslog][message] =~ "Connection closed " {
      mutate {
        id => "syslog-sshd-mutate-rejected-result"
        add_field => { "[ssh][result]" => "Rejected" }
      }
    }
    if [ssh][src] {
      mutate {
        # add dns reverse lookup placeholders      
        id => "syslog-sshd-mutate-src_hostname"
        add_field => { "[ssh][src_hostname]" => "%{[ssh][src]}" }
      }
      # do reverse dns on known ip addresses
      dns {
        id => "syslog-dns-ssh"
        reverse => [ "[ssh][src_hostname]" ]
        action => "replace"
        hit_cache_size => 100
        hit_cache_ttl => 86400
      }
    }
  }
  # sudo template
  else if [syslog][program] == "sudo" {
    grok {
      id => "syslog-grok-sudo"
      match => { 
        "[syslog][message]" => [
          "%{WORD:[sudo_interactive_user]} : %{GREEDYDATA:data}",
          " session %{WORD:[sudo][session]} for user %{WORD:[sudo][user]}",
          "%{GREEDYDATA:[sudo][message]}"          
        ]
      }
    }
    kv {
      id => "syslog-kv-sudo"
      source => "data"
      transform_key => "lowercase"
      field_split => ";"
      trim_key => " "
      trim_value => " "
      target => "sudo"
      allow_duplicate_values => false
      remove_field => "data"
    }
  }
  # arpwatch template
  else if [syslog][program] == "arpwatch" {
    grok {
      id => "syslog-grok-arpwatch"
      match => {
        "[syslog][message]" => [
          "new station %{IP:[arpwatch][src]} %{MAC:[arpwatch][src_mac]} %{WORD:[arpwatch][interface]}"
        ]
      }
    }
    if [arpwatch][src] {
      # add dns reverse lookup placeholders
      mutate {
        id => "syslog-mutate-arpwatch"
        add_field => {
          "[arpwatch][src_hostname]" => "%{[arpwatch][src]}"
        }
      }
      # do reverse dns on known ip fields
      dns {
        id => "syslog-dns-arpwatch"
        reverse => [ "[arpwatch][src_hostname]" ]
        action => "replace"
        hit_cache_size => 100
        hit_cache_ttl => 86400
      }
    }
  }
  # dnsmasq template
  else if [syslog][program] == "dnsmasq" {
    grok {
      id => "syslog-grok-dnsmasq"
      match => {
        "[syslog][message]" => [
          "%{POSINT:[dns][code]} %{IP:[dns][src]}/%{POSINT:[dns][id]} %{WORD:[dns][action]}\[%{WORD:[dns][record]}\] %{DATA:[dns][address]} from %{IPORHOST:[dns][from]}",
          "%{POSINT:[dns][code]} %{IP:[dns][src]}/%{POSINT:[dns][id]} %{WORD:[dns][action]} %{DATA:[dns][address]} is %{GREEDYDATA:[dns][reply]}",
          "%{POSINT:[dns][code]} %{IP:[dns][src]}/%{POSINT:[dns][id]} %{WORD:[dns][action]} %{DATA:[dns][address]} to %{GREEDYDATA:[dns][server]}",
          "%{POSINT:[dns][code]} %{IP:[dns][src]}/%{POSINT:[dns][id]} %{DATA:[dns][block_list]} %{DATA:[dns][address]} is %{GREEDYDATA:[dns][reply]}",
          "%{POSINT:[dns][code]} %{IP:[dns][src]}/%{POSINT:[dns][id]} %{WORD:[dns][action]} %{DATA:[dns][address]} is"          
        ]
      }
    }
  }
  # rename some fields to move them to sub objects
  mutate {
    id => "mutate-final"
    rename => {
      "sudo_interactive_user" => "[sudo][interactive_user]"
      "firewall_action" => "[firewall][action]"
      "syslog_severity_code" => "[syslog][severity][code]"
      "syslog_severity" => "[syslog][severity][name]"
      "syslog_facility_code" => "[syslog][facility][code]"
      "syslog_facility" => "[syslog][facility][name]"
    }
    # remove_field => "message"
  }
}
output {
  stdout { codec => rubydebug }
}